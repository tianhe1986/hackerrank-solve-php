# The Longest Common Subsequence
原题见[这里](https://www.hackerrank.com/challenges/dynamic-programming-classics-the-longest-common-subsequence/problem)

一个序列的子序列，是将原始序列中的一部分元素移除掉，同时保持剩余元素的相对前后关系不变得到的。

而两个序列的最长公共子序列，就是这两个序列能够生成的相同的序列中，长度最长的那个。

现在给定两个由数字构成的数组 A = [a[1], a[2],...a[n]] 和 B = [b[1], b[2],...,b[m]]，找出它们的最长公共子序列并打印出来。如果有多个，打印任意一个即可。

# 分析

找最长公共子序列，这算是一个经典的动态规划题目了。

A的长度为n，B的长度为m， 则令d[i][j]表示序列[a[i],a[i+1],a[i+2],...,a[n]]和[b[j],b[j+1],b[j+2],...,b[m]]能构成的最长公共子序列的长度。有：
* 若a[i] = b[j]， 则d[i][j] = 1 + d[i+1][j+1]，即首个位置元素相同，继续对比后面的位置
* 若a[i] != b[j]，则d[i][j] = max(d[i+1][j], d[i][j+1])，即分别考虑去除两个序列中的首元素，再继续对比。

最后d[0][0]就是所需的答案了。

但是这样有个问题，只能得出最大长度，而没有办法输出实际的序列。那怎么办呢？

方法1，是重新再从d[0][0]开始走一遍，假设process(i, j)表示遍历函数，则：
* 若a[i] = b[j]，则将a[i]加入最终结果，继续处理process(i+1, j+1)
* 若a[i] != b[j]，则若d[i][j] = d[i+1][j]，则继续处理process(i+1, j)，否则继续处理process(i, j+1)。

方法2，是在动态规划时，d[i][j]保存为一个五元组t，含义如下：
* t[0]: 最大长度
* t[1]: A中首个匹配元素位置
* t[2]: B中首个匹配元素位置
* t[3]: A中下一个匹配元素位置
* t[4]: B中下一个匹配元素位置

最终，从d[0][0]开始，输出A中首个匹配元素，再跳到下个匹配位置继续处理输出首个匹配元素，如此反复即可。

我这里用的是方法2，具体代码见[solve.php](./solve.php)