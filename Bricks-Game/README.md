# Bricks Game
原题见[这里](https://www.hackerrank.com/challenges/play-game/problem)

你和你朋友玩一个游戏，一个栈由N个砖块构成，每个砖块上有个数字。

两人轮流行动，你先开始，每次行动，可以选择拿走栈顶的1，2或3个砖块，它们携带的数字会加到对应玩家的总分中去。

你总是选择最优的策略，你的好友也是。问给定初始栈，你能拿到的最大分数。

# 分析
题目的限制条件有这样一条，每个砖块上的数字都是大于等于0的。

这样的话，可以得到一条准则：如果只剩下少于3个砖块了，就全部拿走。

那多于3个砖块的时候呢？当然就是往后不断递推直到小于等于3个砖块为止。

假设a[i]表示砖块i携带的数字，dp[i]表示i之前的砖块已经被拿完了，现在从第i个砖块开始拿，能够拿到的最大总分。此时自然是三种选择：
* 拿a[i]， 然后对方之后会拿到dp[i + 1]的总分。
* 拿a[i] + a[i+1]，对方之后拿到dp[i + 2]。
* 拿a[i] + a[i+1] + a[i+2]，对方之后拿dp[i + 3]。

那么，dp[i]到底是多少呢。

反过来看一下， 假设sum[i]表示从砖块i开始的之后所有砖块的数字之和。则以上三种情况对应的就分别是：
* 拿a[i]， 则最终是 sum[i] - dp[i+1]
* 拿a[i] + a[i+1]，则最终是 sum[i] - dp[i+2]
* 拿a[i] + a[i+1] + a[i+2]，则最终是 sum[i] - dp[i+3]

没错，就是"对方能拿多少分，剩下的分就是自己的"。

所以，每步迭代，就是从dp[i+1],dp[i+2],dp[i+3]中选择一个最小值，即"接下来让对方拿最少的分"。

具体代码见[solve.php](./solve.php)