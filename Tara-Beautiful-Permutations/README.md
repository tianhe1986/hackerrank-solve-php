# Tara's Beautiful Permutations
原题见[这里](https://www.hackerrank.com/challenges/taras-beautiful-permutations/problem)

Tara有一个数组A，由n个数字组成，同一个数在数组中出现次数不会超过2次。

定义P为数组A的一个排列（即更换元素出现的顺序），令p[i]表示P中的第i个位置对应的数字。Tara认为一个排列是优雅的，如果不存在i使得p[i] - p[i+1] = 0。

给定数组，问一共能构成多少个优雅的排列？

# 分析
这题，显然，当然不是显然很容易，而是显然是一个排列组合的题目。“能构成多少种排列，使得没有相邻元素相同”。

直观的处理，当然是，第i个位置选某个元素，然后再去处理第i+1个位置。但这样，就要记录每个元素被选择的情况。

我一开始也是这样想的，然后立马感觉不对，这样需要记录每个元素的状态，动态规划可行性不太高。

再转念一想的时候，突然意识到，并不需要记录每个元素的状态，而是只要记录当前出现次数的总值即可，即记录"出现2次的元素有多少个"和"出现1次的元素有多少个"，当然还需要再记录"前一项是从出现1次还是2次的元素中选的"。

假设dp[i][j][c]表示出现2次的元素有i个，出现1次的元素有j个，且前一项选择类型为c（c=0表示从出现1次的元素中选，c=1表示从出现2次的元素中选），则有：
1. 若 i = 0 且 j = 0， 则 dp[i][j][c] = 1。
2. 若c = 0, 即上一步是从出现1次的元素中选，则这一次选择的时候是没有限制的，可以从出现1次的元素中任选一个，也可以从出现2次的元素中任选一个，有：
    * dp[i][j][c] = i * dp[i - 1][j + 1][1] + j * dp[i][j - 1][0]。 
    前一项是从出现2次的元素中任选一个，选完之后出现2次的元素数量会减1，而出现1次的元素数量会加1。必须 i >= 1才有这一项。
    后一项是从出现1次的元素中任选一个，选完之后出现1次的元素数量会减1.必须 j >= 1才有这一项。
3. 若c = 1，即上一步是从出现2次的元素中选，则这一次，在从出现1次的元素中选时，有一项是不能选的，就是跟上一步相同的那项，则从出现2次的元素可以任选，有：
    * dp[i][j][c] = i * dp[i - 1][j + 1][1] + (j - 1) * dp[i][j - 1][0]。 
    与2中类似，前一项是是从出现2次的元素中任选一个.
    后一项,是从出现1次的元素中选一个,与上一步相同的一项不能选,因此是 j - 1种方式.

这样就能得到结果了。

当然，我这里稍微做了点优化，如果没有出现2次的元素了，就直接取对应的阶乘结果。

具体代码见[solve.php](./solve.php)