# The Longest Increasing Subsequence
原题见[这里](https://www.hackerrank.com/challenges/longest-increasing-subsequent/problem)

这个就是鼎鼎有名的最长单调递增（减）子序列了，既然题目是递增，那就以递增为例。

对于原始序列A，找到一个子序列（去除去序列中的任意个元素，保持剩余元素相对前后位置关系不变）S，使得对于任意i都有S[i] < S[i+1]，这样的子序列就是单调递增子序列。

现在要求最长（即剩余元素最多）的单调递增子序列的元素个数。

# 分析
这是一道挺经典的题目了，我在这里讲讲动态规划的解法，包括O(n^2)的处理方式，和进一步优化成O(nlogn)的解法。

## n方的解法
对于任何一个序列，肯定都有结尾的元素，那么，反过来考虑下，记录以每个位置的元素作为结尾，能构成的单调递增子序列的最大长度。

假设此最大长度记录在数组m中，那么，当要求m[i]时，可以拿i与前面每个位置元素j相比，若A[i] > A[j]，则m[i] = max(m[i], m[j] + 1)，即在之前的结果上多加一个元素。

这样就能依次求出以每个元素作为结尾的单调递增子序列的最大长度了，再取m[i]中最大值即可。

这种方法，在每个位置，都要与前面全部位置比较一遍，则比较次数为1 + 2 + 3 + ... + n - 1 = n * (n - 1) / 2， 为O(n^2)。

## nlogn的解法
在上面的过程中，每个位置，都要跟前面的全部元素去对比一遍，那么，有没有办法，用类似二分查找的方法去处理呢。

当然是有的，不过这个做法比较巧妙，让我自己想恐怕是想不出来的。

用一个数组b来保存，b[i]表示的是，目前为止能够生成的所有长度为i的单调递增子序列中，末尾元素的最小值。

比如说，现在能够生成的长度为2的单调递增子序列有[1, 5], [1, 4]和[1, 3]，则b[2] = 3，它是末尾元素的最小者。

那么，对于此数组，有一条性质：
* b[i+1] > b[i]，即末尾元素的最小者随长度递增。

下面用反证法来证明。

假设 b[i] >= b[i+1]， 那么对于以b[i+1]作为结尾的长度为 i + 1的单调递增子序列来说，设其倒数第二个元素为t， 则有 t < b[i+1] <= b[i]。

那么，以t作为结尾，能够形成一条长度为i的单调递增子序列，且末尾元素比b[i]更小，这跟b[i]是末尾元素的最小值是矛盾的。

这个元素递增的性质有什么用呢，当然就是前面说的，用来二分查找，毕竟二分查找的前提就是数组元素需要是已经排好序的。

具体的使用方法，看接下来的一段，这就是核心巧妙之处了。

从头到尾遍历原始数组A的每个元素，对于A[i]:
* 查找b中大于等于A[i]的第一项。
    * 若没有，则将A[i]追加到b的末尾。
    * 若找到对应项b[j]，则令b[j] = A[i]

最终，b的长度就是最长递增子序列的长度。

来分析下上面的处理过程。

若找不到大于等于A[i]的项，则将A[i]加在b中长度最长的末尾元素之后，可以形成一个新的序列，并且最长长度+1。
因此将A[i]追加到b的末尾，说明新增了一个更长的序列，并且末尾元素最小值是A[i]。

若找到了b[j]使得b[j] >= A[i]，则同时有b[j - 1] < A[i]，那么，如果将A[i]加在b[j-1]的后面，就能形成一个长度为j的序列，并且末尾元素最小值是A[i]。
那么，A[i]就应该取代b[j]，成为长度为j的序列的末尾元素最小值。

这样，处理每个A[i]时，都可以用二分查找，总时间复杂度就是O(nlogn)了。

具体代码见[solve.php](./solve.php)